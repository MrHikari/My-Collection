## Event Loop 事件循环机制

### 基本介绍

***Javascript***自诞生起就是一门**单线程**的**非阻塞**的***脚本语言***。因为其最初的用途来：与**浏览器**交互。

**单线程**：***Javascript***代码在执行的任何时候，都只有***一个*****主线程**来处理所有的任务。

**非阻塞**：当代码需要进行一项**异步任务**的时候，主线程会挂起（*pending*）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

**单线程**是**必要的**，也是***Javascript***语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。
___
#### 同步 与 异步

**同步**和**异步**关注的是`消息通信机制` (**synchronous communication** / **asynchronous communication**)。同步，简而言之就是调用某个程序时，调用方得等待这个调用返回了结果才能继续往后执行。异步，和同步不同，调用方不会等待得到结果，而是在调用发出后调用者可以继续执行后续操作，被调用者通过状态来通知调用者，或者通过回调函数来处理这个调用。
___
#### 阻塞  与 非阻塞

**阻塞**和**非阻塞**关注的是程序在等待`调用结果（消息，返回值）`时的状态。**阻塞调用**是指调用结果返回之前，当前线程会被*挂起*。调用线程只有在*得到结果之后*才会返回。**非阻塞调用**指在不能立刻得到结果之前，该调用不会阻塞当前线程。

***
### 执行栈 与 事件队列

#### 堆（heap） 与 栈（stack）

当***Javascript**代码执行的时候会将不同的变量存于内存中的不同位置：**堆（heap）**和**栈（stack）**中来加以区分。

* **堆（heap）** 是堆内存的简称。
* * 堆（heap）用于**复杂数据类型**（*引用类型*）分配空间，例如 **数组对象**、**object对象**（引用类型的值通常大小不固定，所以被存储在堆内存中）；它是运行时动态分配内存的，因此存取速度较慢。

* **栈（stack）** 是栈内存的简称。
* * 栈（stack）中主要存放一些**基本类型**（*Undefined*、*Null*、*Boolean*、*Number* 和 *String*）的变量和*对象的引用*（基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中），其优势是存取速度比堆要快，并且栈内的数据可以共享，但缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

各种语言在处理堆栈的原理上都大同小异。**堆**是动态分配内存，内存大小不一，也不会自动释放。**栈**是自动分配相对固定大小的内存空间，并由系统自动释放。

**堆**和**栈**都是运行时**内存**中分配的一个数据区，因此也被称为堆区和栈区，但二者存储的数据类型和处理速度不同。

#### 深拷贝于浅拷贝

___
#### 执行栈

&emsp;&emsp;当调用一个方法的时候，js会生成一个与这个方法对应的**执行环境**（*context*），又叫执行上下文。**注意**:这个执行环境中存在着**这个方法的私有作用域**，**上层作用域的指向**，**方法的参数**，**这个作用域中定义的变量**以及**这个作用域的this对象**。 而当**一系列**方法被**依次调用**的时候，由于js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为**执行栈**。

**举例**：当一个脚本（一段代码）第一次执行的时候，js引擎会解析这段代码，并将其中的**同步代码**按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会**退出这个执行环境**并把这个执行环境**销毁**，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

内存分配和垃圾回收
一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。
垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。

JavaScript堆不需要程序代码来显示地释放，因为堆是由自动的垃圾回收来负责的，每种浏览器中的JavaScript解释引擎有不同的自动回收方式，但一个最基本的原则是：如果栈中不存在对堆中某个对象的引用，那么就认为该对象已经不再需要，在垃圾回收时就会清除该对象占用的内存空间。因此，在不需要时应该将对对象的引用释放掉（解除引用），以利于垃圾回收，这样就可以提高程序的性能。释放对对象的引用最常用的方法就是为其赋值为null，这种做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用，
