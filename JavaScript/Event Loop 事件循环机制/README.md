## Event Loop 事件循环机制

### 基本介绍

***Javascript***自诞生起就是一门**单线程**的**非阻塞**的***脚本语言***。因为其最初的用途来：与**浏览器**交互。

**单线程**：***Javascript***代码在执行的任何时候，都只有***一个*****主线程**来处理所有的任务。

**非阻塞**：当代码需要进行一项**异步任务**的时候，主线程会挂起（*pending*）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

**单线程**是**必要的**，也是***Javascript***语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果***Javascript***是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，***Javascript***选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。

&emsp;&emsp;**JS引擎**在执行代码时若果遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行**执行栈**中的其他任务。当一个异步事件返回结果后，***js***会将这个事件加入与当前执行栈不同的另一个队列，我们称之为**事件队列**。被放入事件队列不会立刻执行其回调，而是等待当前**执行栈**中的*所有任务*都执行完毕，主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（**Event Loop**）”的原因。
___
#### 同步 与 异步

**同步**和**异步**关注的是`消息通信机制` (**synchronous communication** / **asynchronous communication**)。同步，简而言之就是调用某个程序时，调用方得等待这个调用返回了结果才能继续往后执行。异步，和同步不同，调用方不会等待得到结果，而是在调用发出后调用者可以继续执行后续操作，被调用者通过状态来通知调用者，或者通过回调函数来处理这个调用。
___
#### 阻塞 与 非阻塞

**阻塞**和**非阻塞**关注的是程序在等待`调用结果（消息，返回值）`时的状态。**阻塞调用**是指调用结果返回之前，当前线程会被*挂起*。调用线程只有在*得到结果之后*才会返回。**非阻塞调用**指在不能立刻得到结果之前，该调用不会阻塞当前线程。

***

### 执行栈 与 事件队列

#### 堆（heap） 与 栈（stack）

当***Javascript**代码执行的时候会将不同的变量存于内存中的不同位置：**堆（heap）**和**栈（stack）**中来加以区分。

* **堆（heap）** 是堆内存的简称。
* * 堆（heap）用于**复杂数据类型**（*引用类型*）分配空间，例如 **数组对象**、**object对象**（引用类型的值通常大小不固定，所以被存储在堆内存中）；它是运行时动态分配内存的，因此存取速度较慢。

* **栈（stack）** 是栈内存的简称。
* * 栈（stack）中主要存放一些**基本类型**（*Undefined*、*Null*、*Boolean*、*Number* 和 *String*）的变量和*对象的引用*（基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中），其优势是存取速度比堆要快，并且栈内的数据可以共享，但缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。

各种语言在处理堆栈的原理上都大同小异。**堆**是动态分配内存，内存大小不一，也不会自动释放。**栈**是自动分配相对固定大小的内存空间，并由系统自动释放。

**堆**和**栈**都是运行时**内存**中分配的一个数据区，因此也被称为堆区和栈区，但二者存储的数据类型和处理速度不同。
___
#### 深拷贝于浅拷贝

**浅拷贝**（*shallowCopy*）只是增加了一个**指针**指向已存在的内存地址，

**深拷贝**（*deepCopy*）是增加了一个指针并且申请了一个**新的内存**，使这个增加的指针指向这个新的内存。
___
#### 内存分配 和 垃圾回收

一般来说**栈内存**线性有序存储，容量小，系统分配效率高。而**堆内存**首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，从而效率相对就要低一些了。

垃圾回收方面，**栈内存**变量基本上**用完就回收**了，而**堆内存**中的变量因为存在很多不确定的引用，只有当**所有**调用的变量全部销毁之后才能回收。

***JavaScript*** 堆不需要程序代码来显示地释放，因为堆是由自动的垃圾回收来负责的，每种浏览器中的**JavaScript解释引擎**有不同的自动回收方式，但一个最基本的原则是：如果**栈**中不存在对**堆**中某个对象的***引用***，那么就认为该对象已经不再需要，在垃圾回收时就会清除该对象占用的内存空间。因此，在**不需要时**应该将对对象的引用**释放掉**（解除引用），以利于垃圾回收，这样就可以提高程序的性能。释放对对象的引用最常用的方法就是为其***赋值为***`null`，这种做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用，
___
#### 执行栈

&emsp;&emsp;当调用一个方法（或者一段代码）的时候，***js***会生成一个与这段代码对应的**执行环境**（*context*），又叫执行上下文。**注意**:这个执行环境中存在着**这个方法的私有作用域**，**上层作用域的指向**，**方法的参数**，**这个作用域中定义的变量**以及**这个作用域的this对象**。 而当**一系列**方法被**依次调用**的时候，由于***js***是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为**执行栈**。

**举例**：当一个脚本（一段代码）第一次执行的时候，***js***引擎会解析这段代码，并将其中的**同步代码**按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么***js***会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，***js***会**退出这个执行环境**并把这个执行环境**销毁**，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

***

### macrotask 宏任务 与 microtask 微任务

**task（任务）** ***JavaScript***的**异步任务**分为两大类，分别是 **macrotask** （宏任务）和 **microtask**（微任务）。

**macrotask** （宏任务） 主要包含：`script(整体代码)`、`setTimeout`、`setInterval`、`I/O`、`UI 交互事件`、`setImmediate(Node.js 环境)`。

**microtask**（微任务） 主要包含：`Promise`、`MutaionObserver`、`process.nextTick(Node.js 环境)`。

![JS任务导图](https://upload-images.jianshu.io/upload_images/27828718-c16b4dc2175283ef.png)

&emsp;&emsp;当程序执行时，每次 **执行栈** 的 *同步任务* 执行完毕，就会从 *任务队列* 中取出 *完成的异步任务*，队列中又分为 微任务队列 和 宏任务队列 等到把 **microtasks queues**（微任务队列） ***所有的*** **microtasks**（微任务） 都执行完毕， 从宏任务队列中取任务。等到把队列中的事件取出一个，放入 **执行栈** 执行完成，就算一次循环结束，之后`event loop`还会继续循环，再执行 **microtasks queues** 所有的任务，然后再从宏任务队列里面取一个，如此反复循环。

**执行顺序**
1. 同步任务执行完

2. 去执行**microtasks**，把所有***microtasks queues***清空

3. 取出一个***macrotasks queues***的完成事件，在执行栈执行

4. 再去执行**microtasks**

5. ......（循环往复）

![JS事件循环示意](https://pic2.zhimg.com/80/v2-e6dd78c74cb671dd9408c2273308a265_1440w.jpg)

`setTimeout`/`Promise` 等API便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自**不同任务源**的任务会进入到不同的任务队列。其中 `setTimeout` 与 `setInterval` 是同源的。

在当前执行栈执行完毕时会立刻先处理所有**微任务队列**中的事件，然后再去**宏任务队列**中取出一个事件。<br/>
**注意**：同一次事件循环中，微任务永远在宏任务**之前**执行。在当前的微任务没有执行完成时，是不会执行下一个宏任务的。
