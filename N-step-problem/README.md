### 台阶问题

#### 问题介绍

&emsp;&emsp;有 N 阶台阶，每一步可以走 1 步台阶或者 2 步台阶，求出走到第 N 阶台阶的方法数。

#### 解答

&emsp;&emsp;这是一个涉及递归算法的问题。直白的解释一下的话，就像组建两个二叉树，第一步可以是 1 步或者 2 步，第二步在第一步的基础上，可能也是 1 步或者 2 步。于是第二步在第一步的基础上，衍生出了 4 种状况。即，第一步 1 步，第二步 1 步；第一步 1 步，第二步 2 步；第一步 2 步，第二步 1 步；第一步 2 步，第二步 2 步。依次走下去，种类越来越多。

&emsp;&emsp;然后为了到达第 N 阶的台阶，就要注意一共走了多少步。比如当跨完第一步是 1 步时，那么剩下的**N-1**阶开始考虑要通过多少种方式到达。每完成一步，意味着重新计算新的种类，当然这里不考虑走过了回头这种骚操作。所以可先先从第一步直白简单理解为，到达**N**阶的方式总数是第一步迈出**1**步到达 N 阶的**方式总数**和第一步迈出**2**步到达 N 阶的**方式总数**的**和**。<br/>

> F(N) = F(N-1) + F(N-2);

（递归调用是一种特殊的嵌套调用，是某个函数调用自己或者是调用其他函数后再次调用自己的，只要函数之间互相调用能产生循环的则一定是递归调用，递归调用一种解决方案，一种是逻辑思想。）

```c
#include<stdio.h>

int count;    // 计数变量,计算最后统计的方式数量

void total(int n,int step)
{
    if(step>n)    // 当走过的台阶大于总台阶数，不计算
        return;
    if(step==n)   // 当走过的台阶正好等于总台阶数时，计算最后一次
    {
        count++;
        return;
    }

    total(n,step+1);    // 决定总台阶后，迈出1步，递归调用
    total(n,step+2);    // 决定总台阶后，迈出2步，递归调用
}

int main()
{
    int n;              // 定义N阶
    total(n,0);         // 执行方法
    return 0;
}
```

&emsp;&emsp;如果还差一步（步骤）到达 N 阶，那么在这一步之前会有两种方式，即迈出 1 步到达 N-1 阶，结果只能再迈 1 步（没有选择了），到达终点 N 阶，那么其实到**N-1**阶的时候，方式计算就结束了，所以可以看做到达**N-1**的方式总数。同理如果还差 2 步到达 N 阶，但是已经决定一次跨越 2 步到达，那么没有选择了，可以看做到达**N-2**的方式总数。所以到达 N 阶的方式和依然可以看做：<br/>

> F(N) = F(N-1) + F(N-2);

```
#include <stdio.h>
#include <stdlib.h>

int fun(int n){
    if(n <= 0)     // 溢出，方法作废
        return 0;
    if(n == 1)     // 还差1步
        return 1;
    if(n == 2)     // 还差2步
        return 2;
    return fun(n-1)+fun(n-2);   // 运用了斐波那契数列算法
}

int main()
{
    int N;
    fun(N);       // 计算上N阶的方法
    return 0;
}
```
