### 发展史

&emsp;&emsp;在网络发展的最开始阶段，Web 基本上只能浏览文档，只不过你不需要去作者家里看文档了。 既然是浏览文档，服务器就没必要记录用户在某一段时间里都浏览了什么文档，就像市场的一个大告示牌，只不过是你想看信息的时候，告知它显示给自己看。浏览器每次请求都是一个新的HTTP协议， 就是请求（req）加响应（res），服务器不用记录是哪位用户刚刚发起了HTTP请求，服务器对于每个请求都会作出响应。

&emsp;&emsp;但是，人类是永远不知足的。随着交互式Web应用的兴起，例如在线购物，在线付费观看等，需要登录相关网页，这时问题伴随出现了，服务器要管理会话，服务器必须判断哪些用户登录系统，哪些用户在进行各自的操作，通俗的解释就是服务器必须把每个用户区分。相对于原先的静态浏览，这就需要技术上的革新了，因为HTTP请求是无状态的，所以当时想出的办法就是给所有用户发送一个会话标识(session id), 就是一个由服务器随机生成的字符串，每个用户收到一个id，这些id各不相同，用户发起HTTP请求的时候，把自己收到的id字符串给一并发送给服务器，服务器根据获取的（session id）确认是哪一位用户。

&emsp;&emsp;虽然这是一个解决交互的手段，但是庞大的用户数量会给服务器造成极大的压力。因为尽管每个用户的浏览器只需要保存自己的（session id），但是服务器要保存所有用户的（session id）！打个比方，如果阿里的服务需要保存所有的用户的（session id），那服务器体积得抽出多大的空间，再加上备用服务器！马爸爸估计都要哭了！

&emsp;&emsp;所以上述的方案极大消耗着服务器资源，严重限制了服务器的扩展能力。例如当多个服务器组成了一个集群，用户A通过服务器X发出请求，登录了系统，那A用户的（session id）会保存在服务器A上。  假设A用户的下一次请求被转发到服务器B上，或者服务器A的所在地忽然地震，服务器A挂掉了，那么服务器B无法判断A的登录状况，如果重新发送一个（session id），这就陷入了一个巨大的无底洞的消耗中。

&emsp;&emsp;那么出现了一个简单粗暴的方法：粘滞会话（session sticky），就是让用户A的请求一直粘连在服务器A上，但是当服务器A down了，那用户也只能认命，（session id）丢失。另一种方法就是个砸钱的方法：复制会话（session replication），例如用户B访问了一次，服务器就将用户B的（session id）复制到所有的服务器。这样就解决了如果用户B正在访问的服务器down了，用户B会被自动被转到别的服务器上，并且（session id）不会丢失。当然缺点是效率低，一个用户的（session id）被搬到所有的服务器上，并且，最重要的是烧钱。

![粘滞会话图示](/uploads/beb194de0e329179ddf7e920f1404e27/image.png)
![复制会话图示](/uploads/564dbd5df61d7e940b36eaefa8851598/image.png)

&emsp;&emsp;后来有个Memcached的系统建议：把（session id）集中存储到一个服务器上，所有的服务器都来访问这个地方的数据， 如此就不用在各个服务器之间相互复制更新（session id），但是增加了单点失败的可能性， 要是那个负责（session id）的服务器down了，所有人的登录状态都没了，估计麻花藤不太敢用，可以想象玩家的集体爆破。

![负载均衡处理图示](/uploads/2642b674b6aa9bcf3bbba9c4454b0c62/image.png)

&emsp;&emsp;为了增加可靠性，那么尝试把这个单点的服务器也搞出集群，增加可靠性，烧钱，烧钱，所以对服务器来说（session）是一个沉重的负担。

&emsp;&emsp;于是有人就一直在思考，为什么要让服务器保存session呢？让每个客户端去保存不就OK了？！

&emsp;&emsp;如果服务器不保存这些（session id），那么服务器如何验证客户端发送的（session id）是不是本服务集群生成的呢？  如果不去验证，服务器就无法得部分用户是不是合法登录的用户，不法分子就会伪造（session id）然后对运营公司造成极大的损失。

&emsp;&emsp;所以服务器一直致力于处理解决用户的验证问题，毕竟大部分服务都涉及到资金交易，毕竟运营服务肯定是为了盈利的。那么验证该怎么革新呢？于是，（token）开始应用。举个例子：A用户登录了系统，服务器给A用户返回了一个令牌(token)，（token）中包含了A用户的id标识，A用户接下来通过Http请求访问该服务的时候，把（token）通过Http的header信息捎带着发送给服务器。虽然在构造方法上（token）和（session id）没有本质区别，虽然任何用户都可以伪造（token），但是服务器有专门的验证方式。服务器在给客户端的数据上做一个签名， 比如使用一些加密算法，例如MD5或者sha1算法，加上一个记录在服务器上的密钥，将签名和数据一起作为token ，由于一般用户更本不知道秘钥是什么，所以无法伪造有效的token。

![token数据的生成](/uploads/cabfe236bba227bf96c970f74315b6e9/image.png)

&emsp;&emsp;（token）信息服务器并不保存，A用户在请求服务的时候顺带上（token）信息，服务端利用所使用的算法和保存的密钥，对用户数据进行一次签名处理，然后和（token）中的签名做个比较，如果相同，我就知道小F已经登录过了，并且可以直接取到小F的(user id)等基本信息, 如果不相同， 数据部分肯定是不正确，服务器就会拒绝该登录请求。

![token数据的验证](/uploads/85c680fcce8973810106129f1db56c68/image.png)

&emsp;&emsp;Token中的数据是明文保存，尽管（token）中不存储密码等一类的敏感信息，但是别人获得了，复制粘贴，服务器还是承认的请求的。就像别人获取了你的车钥匙开走你的车一样的道理。

&emsp;&emsp;服务器终于可以释放大量的空间，扬眉吐气了，只需要消耗CPU计算session的合理性即可，随着科技的不断进步，CPU当然是越来越强大，价格也趋向平常化，广大的网络运行服务商，何乐不为。于是服务器集群现在可以轻松地做水平扩展，即使用户访问量增大， 直接加机器或者升级CPU就够了。

<br/>

---

### Cookie

Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。

&emsp;&emsp;内存Cookie由浏览器维护，保存在内存中，浏览器关闭后Cookie就消失了，其存在时间是短暂的。<br/>
&emsp;&emsp;硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。<br/>
&emsp;&emsp;所以，按存在时间，可分为非持久Cookie和持久Cookie。

#### 用途

&emsp;&emsp;因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，因为HTTP的无状态性，如果不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”***之一***。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。

&emsp;&emsp;在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。

&emsp;&emsp;Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。

#### Cookie的缺陷

1. Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。
2. 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。
3. Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。

<br/>

---

### Session

&emsp;&emsp;Session，从字面上讲，就是会话。在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web页时，如果该用户还没有会话，则Web服务器将自动创建一个 Session对象。当会话过期或被放弃后，服务器将终止该会话。注意会话状态仅在支持cookie的浏览器中保留。

&emsp;&emsp;服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候，原先的session将不被认可。

<br/>

---

### Token

&emsp;&emsp;Token，一种身份验证信息，在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，token 是在多用户下处理认证的最佳方式。

程序中使用基于Token的身份验证的一些特性：
1. 无状态、可扩展
2. 支持移动设备
3. 跨程序调用
4. 安全性高

&emsp;&emsp;很多大型网站也都在用，比如 Facebook，Twitter，Google+，Github 等等。

<br/>

#### 基于 Token 的身份验证方法

使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

<br/>

#### Json Web Token（JWT）

&emsp;&emsp;JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 ***JSON*** 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。
它具备两个特点：
1. 简洁(Compact)<br/>可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快
2. 自包含(Self-contained)<br/>负载中包含了所有用户所需要的信息，避免了多次查询数据库

#### JWT 组成

**Header** 头部

Header包含了两部分，token 类型和采用的加密算法
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
它会使用 Base64 编码组成 JWT 结构的第一部分。

Base64是一种编码，它是可以被翻译回原来的样子来的。它并不是一种加密过程。

**Payload** 负载

Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，也可以添加其它需要的内容例如name和admin等。下面是标准字段：

* iss：Issuer，发行者
* sub：Subject，主题
* aud：Audience，观众
* exp：Expiration time，过期时间
* nbf：Not before
* iat：Issued at，发行时间
* jti：JWT ID

例如：
```
{
    "iss": "jijizhazha",
    "iat": 19******00,
    "exp": 19******00,
    "aud": "www.xxxxxxx@xx.com",
    "sub": "xxxxxxxxxx"
}
```

同样的，它也会使用 Base64 编码组成 JWT 结构的第二部分

**Signature** 签名

前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及服务端提供的一个密钥，然后使用 header 中指定的签名算法（例如：HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。

三个部分通过.连接在一起就是我们的 JWT 了，它可能长这个样子，长度貌似和你的加密算法和私钥有关系。

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoiano2IiwiaWF0IjoxNTY3NTgzNzU1fQ.CmcM2q10KGzRhj0xtUe-YBtpIRrN_KuphhLc80HkC38
```

***签名的目的***

最后一步签名的过程，实际上是对Header头部以及Payload负载内容进行签名，防止内容被窜改。如果只是单单对头部以及负载的内容解码之后进行修改，再进行编码，最后加上原来的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。

Token中不存储敏感的身份信息（例如：密码 等），因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。

<br/>

---

参考资料：
* 维基百科
* 百度百科
* 码农翻身
* CSDN论坛